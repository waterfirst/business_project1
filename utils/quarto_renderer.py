# utils/quarto_renderer.py
import os
import subprocess
import tempfile
from pathlib import Path
from typing import Optional, List
import textwrap

class QuartoRenderer:
    """Quarto ë¬¸ì„œ ìƒì„± ë° ë Œë”ë§"""
    
    def __init__(self):
        self.temp_dir = Path(tempfile.mkdtemp())
        
    def create_qmd_document(
        self, 
        title: str,
        author: str,
        experiment_date: str,
        code_chunks: List[dict],
        theme: str = "cosmo",
        code_fold: bool = True,
        output_path: Optional[str] = None
    ) -> Path:
        """Quarto ë¬¸ì„œ ìƒì„± (v4.0 - í†µí•© ë§ˆìŠ¤í„° í…œí”Œë¦¿ ì ìš©)"""
        
        # Determine engine
        is_r = any(chunk.get('language', '').lower() == 'r' for chunk in code_chunks)
        engine_section = "engine: knitr" if is_r else "jupyter: python3"
        
        # Python path for reticulate
        python_executable = "C:/Users/nakch/AppData/Local/Programs/Python/Python313/python.exe"

        # Assemble Master Template
        lines = []
        lines.append("---")
        lines.append(f'title: "{title}"')
        lines.append('subtitle: "AI-Powered Scientific Data Analysis & Visualization"')
        lines.append(f'author: "{author}"')
        lines.append(f"date: {experiment_date}")
        lines.append("lang: ko")
        lines.append(engine_section)
        lines.append("format:")
        lines.append("  html:")
        lines.append(f"    theme: {theme}")
        lines.append("    toc: true")
        lines.append("    code-fold: true")
        lines.append('    code-summary: "ë¶„ì„ ì½”ë“œ í™•ì¸"')
        lines.append("    code-tools: true")
        lines.append("    df-print: paged")
        lines.append("    embed-resources: true")
        lines.append("    html-math-method: katex")
        lines.append("  pdf:")
        lines.append("    toc: true")
        lines.append("    number-sections: true")
        lines.append("    colorlinks: true")
        lines.append("    df-print: kable")
        lines.append('    mainfont: "NanumGothic"') # Or "Malgun Gothic"
        lines.append("    header-includes: |")
        lines.append("      \\usepackage{chemfig}")
        lines.append("execute:")
        lines.append("  warning: false")
        lines.append("  message: false")
        lines.append("  echo: false")
        lines.append("---")
        lines.append("")
        
        # R-Python Interoperability Setup if R is used
        if is_r:
            lines.append("```{r}")
            lines.append("#| label: setup-interop")
            lines.append("#| include: false")
            lines.append("library(reticulate)")
            lines.append(f'try(use_python("{python_executable}"), silent = TRUE)')
            lines.append("```")
            lines.append("")

        lines.append("# ë¶„ì„ ê°œìš”")
        lines.append("")
        lines.append(f"ë³¸ ë¬¸ì„œëŠ” **{author}** ì—°êµ¬ì›ì´ ìˆ˜í–‰í•œ **{title}** ì‹¤í—˜ì˜ ì§€ëŠ¥í˜• ë¶„ì„ ê²°ê³¼ì…ë‹ˆë‹¤.")
        lines.append("")
        
        # Content Blocks
        for i, chunk in enumerate(code_chunks, 1):
            lang = chunk.get('language', 'python')
            code = chunk.get('code', '')
            caption = chunk.get('caption', f'Analysis {i}')
            interpretation = chunk.get('interpretation', '')
            
            lines.append(f"# {i}. {caption}")
            lines.append("")
            
            lines.append(f"```{{{lang}}}")
            lines.append(f"#| label: analysis-{i}")
            lines.append(f'#| fig-cap: "{caption}"')
            lines.append("#| echo: false")
            lines.append("")
            lines.append(code)
            lines.append("")
            lines.append("```")
            lines.append("")
            
            if interpretation:
                lines.append("::: {.callout-note}")
                lines.append(f"## ğŸ’¡ {caption} ê²°ê³¼ í•´ì„")
                lines.append("")
                lines.append(interpretation)
                lines.append(":::")
                lines.append("")
            
            lines.append("---")
            lines.append("")

        # Footer
        lines.append("# ê²°ë¡ ")
        lines.append("")
        lines.append("ì‹¤í—˜ ë°ì´í„°ì™€ AI ê¸°ë°˜ ë¶„ì„ì„ ì¢…í•©í•œ ê²°ê³¼ì…ë‹ˆë‹¤. í†µê³„ì  ìœ ì˜ì„±ì€ ì‹¤í—˜ ì¡°ê±´ì— ë”°ë¼ ì¬ê²€í† ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        lines.append("")
        lines.append("---")
        lines.append(f"*Generated by Bio-Log Professional v4.0 - Stable Master Template*")

        content = "\n".join(lines)
        
        if output_path is None:
            output_path = self.temp_dir / "report.qmd"
        else:
            output_path = Path(output_path)
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        # Force standard UTF-8 for broadest compatibility across R/Python kernels
        output_path.write_text(content, encoding='utf-8')
        
        return output_path
    
    def _decode_output(self, output_bytes: bytes) -> str:
        """í•œê¸€ ìœˆë„ìš°(CP949)ì™€ UTF-8 ëª¨ë‘ ëŒ€ì‘í•˜ëŠ” ë””ì½”ë”©"""
        for encoding in ['utf-8', 'cp949', 'euc-kr']:
            try:
                return output_bytes.decode(encoding)
            except UnicodeDecodeError:
                continue
        return output_bytes.decode('utf-8', errors='replace')

    def render_to_html(self, qmd_path: Path) -> Path:
        """Quarto ë¬¸ì„œë¥¼ HTMLë¡œ ë Œë”ë§"""
        
        # Enforce UTF-8 for subprocess (Crucial for Windows)
        env = os.environ.copy()
        env['PYTHONUTF8'] = '1'
        env['PYTHONIOENCODING'] = 'utf-8'
        env['LANG'] = 'ko_KR.UTF-8'
        
        try:
            result = subprocess.run(
                ['quarto', 'render', str(qmd_path), '--to', 'html'],
                capture_output=True,
                check=True,
                timeout=120, # Increased timeout for complex renders
                cwd=str(qmd_path.parent),
                env=env
            )
            
            html_path = qmd_path.with_suffix('.html')
            
            if not html_path.exists():
                raise FileNotFoundError(f"ë Œë”ë§ ì™„ë£Œë˜ì—ˆìœ¼ë‚˜ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {html_path}")
            
            return html_path
            
        except subprocess.TimeoutExpired:
            raise RuntimeError("ë Œë”ë§ ì‹œê°„ ì´ˆê³¼ (60ì´ˆ)")
        except subprocess.CalledProcessError as e:
            error_msg = f"Quarto ë Œë”ë§ ì‹¤íŒ¨ (exit code {e.returncode}):\n"
            stdout_text = self._decode_output(e.stdout) if e.stdout else ""
            stderr_text = self._decode_output(e.stderr) if e.stderr else ""
            
            if stdout_text:
                error_msg += f"--- STDOUT ---\n{stdout_text}\n"
            if stderr_text:
                error_msg += f"--- STDERR ---\n{stderr_text}\n"
            raise RuntimeError(error_msg)
        except FileNotFoundError:
            raise RuntimeError("Quartoê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. https://quarto.org ì—ì„œ ì„¤ì¹˜í•˜ì„¸ìš”.")
    
    def render_to_pdf(self, qmd_path: Path) -> Path:
        """Quarto ë¬¸ì„œë¥¼ PDFë¡œ ë Œë”ë§"""
        
        # Enforce UTF-8 for subprocess
        env = os.environ.copy()
        env['PYTHONUTF8'] = '1'
        env['PYTHONIOENCODING'] = 'utf-8'
        
        try:
            result = subprocess.run(
                ['quarto', 'render', str(qmd_path), '--to', 'pdf'],
                capture_output=True,
                check=True,
                timeout=180, # PDF rendering takes longer
                cwd=str(qmd_path.parent),
                env=env
            )
            
            pdf_path = qmd_path.with_suffix('.pdf')
            
            if not pdf_path.exists():
                raise FileNotFoundError(f"PDF ìƒì„± ì‹¤íŒ¨: {pdf_path}")
            
            return pdf_path
            
        except subprocess.CalledProcessError as e:
            if e.stderr and (b"pdflatex" in e.stderr or b"xelatex" in e.stderr):
                raise RuntimeError(
                    "PDF ìƒì„±ì— í•„ìš”í•œ LaTeXê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
                    "TinyTeX ì„¤ì¹˜: quarto install tinytex"
                )
            else:
                error_msg = f"PDF ë Œë”ë§ ì‹¤íŒ¨ (exit code {e.returncode}):\n"
                stdout_text = self._decode_output(e.stdout) if e.stdout else ""
                stderr_text = self._decode_output(e.stderr) if e.stderr else ""
                
                if stdout_text:
                    error_msg += f"--- STDOUT ---\n{stdout_text}\n"
                if stderr_text:
                    error_msg += f"--- STDERR ---\n{stderr_text}\n"
                raise RuntimeError(error_msg)
