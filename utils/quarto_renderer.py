# utils/quarto_renderer.py
import subprocess
import tempfile
from pathlib import Path
from typing import Optional, List
import textwrap

class QuartoRenderer:
    """Quarto ë¬¸ì„œ ìƒì„± ë° ë Œë”ë§"""
    
    def __init__(self):
        self.temp_dir = Path(tempfile.mkdtemp())
        
    def create_qmd_document(
        self, 
        title: str,
        author: str,
        experiment_date: str,
        code_chunks: List[dict],
        theme: str = "cosmo",
        code_fold: bool = True,
        output_path: Optional[str] = None
    ) -> Path:
        """Quarto ë¬¸ì„œ ìƒì„±"""
        
        # Determine processing engine based on language
        is_r = any(chunk.get('language', '').lower() == 'r' for chunk in code_chunks)
        engine_section = "engine: knitr" if is_r else "jupyter: python3"
        
        # Professional CSS for the report
        custom_css = """
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono&display=swap');

body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  line-height: 1.6;
}

.quarto-title-block .quarto-title-banner {
  background: linear-gradient(135deg, #1a2a6c 0%, #b21f1f 50%, #fdbb2d 100%);
  padding: 3rem 0;
  color: white;
  margin-bottom: 2rem;
}

.quarto-title-meta {
  border-top: 1px solid #eee;
  padding-top: 1.5rem;
  margin-top: 1rem;
}

h2 {
  color: #2c3e50;
  border-bottom: 2px solid #3498db;
  padding-bottom: 0.5rem;
  margin-top: 2.5rem;
}

.callout {
  border-radius: 12px !important;
  box-shadow: 0 4px 6px rgba(0,0,0,0.05);
}

.abstract-box {
  background: #f8f9fa;
  padding: 1.5rem;
  border-radius: 12px;
  border-left: 5px solid #3498db;
  margin-bottom: 2rem;
}
"""
        # Write CSS to a file to avoid YAML indentation issues
        css_path = self.temp_dir / "custom_style.css"
        css_path.write_text(custom_css, encoding='utf-8-sig')

        # Prepare YAML header with folding and professional theme
        # We use dedent and no leading whitespace for markers
        yaml_header = textwrap.dedent(f"""\
            ---
            title: "{title}"
            subtitle: "AI-Powered Bio-Data Analysis Insights"
            author: "{author}"
            date: "{experiment_date}"
            lang: ko
            {engine_section}
            format:
              html:
                theme: flatly
                css: custom_style.css
                code-fold: true
                code-summary: "ì†ŒìŠ¤ ì½”ë“œ ë³´ê¸°"
                toc: true
                toc-location: left
                number-sections: true
                embed-resources: true
                html-math-method: katex
              pdf:
                documentclass: article
                mainfont: "NanumGothic"
            execute:
              warning: false
              message: false
            ---

            """).strip() + "\n\n"
        
        abstract = textwrap.dedent(f"""\
            ## ì‹¤í—˜ ìš”ì•½ ë° ì»¨í…ìŠ¤íŠ¸ {{.unnumbered}}

            ::: {{.abstract-box}}

            ::: {{.grid}}

            ::: {{.g-col-6}}
            - **ì‹¤í—˜ ì œëª©**: {title}
            - **ì±…ì„ ì—°êµ¬ì›**: {author}
            - **ì‹¤í—˜ ì¼ì‹œ**: {experiment_date}
            :::

            ::: {{.g-col-6}}
            - **ë¶„ì„ ì‹œìŠ¤í…œ**: Bio-Log v2.7
            - **ì§€ëŠ¥í˜• ì—”ì§„**: Google Gemini 2.5
            - **ìˆ˜í–‰ëœ ë¶„ì„**: ì´ {len(code_chunks)}ê°œì˜ ë¶„ì„ ì„¸íŠ¸
            :::

            :::

            :::

            ---

            """).strip() + "\n\n"
        
        content = yaml_header + abstract
        
        for i, chunk in enumerate(code_chunks, 1):
            lang = chunk.get('language', 'python')
            code = chunk.get('code', '')
            caption = chunk.get('caption', f'ë¶„ì„ {i}')
            interpretation = chunk.get('interpretation', '')
            
            # Ensure code blocks start at Col 0
            content += f"## ë¶„ì„ {i}: {caption}\n\n"
            
            content += textwrap.dedent(f"""\
                ```{{{lang}}}
                #| label: fig-analysis-{i}
                #| fig-cap: "{caption}"

                {code}
                ```

                """).strip() + "\n\n"
            
            if interpretation:
                content += textwrap.dedent(f"""\
                    ::: {{.callout-note appearance="simple"}}
                    ### ğŸ’¡ ê²°ê³¼ í•´ì„

                    {interpretation}
                    :::

                    """).strip() + "\n\n"
            
            content += "---\n\n"
        
        content += textwrap.dedent(f"""\
            ## ê²°ë¡  ë° ì œì–¸ {{.unnumbered}}

            ë³¸ ë¶„ì„ì€ Google Gemini AIë¥¼ í™œìš©í•˜ì—¬ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. 
            í†µê³„ì  ê²°ê³¼ëŠ” ì‹¤í—˜ ì„¤ê³„ì™€ ë°ì´í„° í’ˆì§ˆì— ë”°ë¼ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, 
            í•­ìƒ ë„ë©”ì¸ ì „ë¬¸ê°€ì˜ ê²€í† ê°€ í•„ìš”í•©ë‹ˆë‹¤.

            ---

            *Generated by Bio-Log - AI-Powered Lab Notebook (v2.7)*
            """).strip()
        
        if output_path is None:
            output_path = self.temp_dir / "report.qmd"
        else:
            output_path = Path(output_path)
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content, encoding='utf-8-sig')
        
        return output_path
    
    def _decode_output(self, output_bytes: bytes) -> str:
        """í•œê¸€ ìœˆë„ìš°(CP949)ì™€ UTF-8 ëª¨ë‘ ëŒ€ì‘í•˜ëŠ” ë””ì½”ë”©"""
        for encoding in ['utf-8', 'cp949', 'euc-kr']:
            try:
                return output_bytes.decode(encoding)
            except UnicodeDecodeError:
                continue
        return output_bytes.decode('utf-8', errors='replace')

    def render_to_html(self, qmd_path: Path) -> Path:
        """Quarto ë¬¸ì„œë¥¼ HTMLë¡œ ë Œë”ë§"""
        
        try:
            result = subprocess.run(
                ['quarto', 'render', str(qmd_path), '--to', 'html'],
                capture_output=True,
                check=True,
                timeout=60,
                cwd=str(qmd_path.parent)
            )
            
            html_path = qmd_path.with_suffix('.html')
            
            if not html_path.exists():
                raise FileNotFoundError(f"ë Œë”ë§ ì™„ë£Œë˜ì—ˆìœ¼ë‚˜ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {html_path}")
            
            return html_path
            
        except subprocess.TimeoutExpired:
            raise RuntimeError("ë Œë”ë§ ì‹œê°„ ì´ˆê³¼ (60ì´ˆ)")
        except subprocess.CalledProcessError as e:
            error_msg = f"Quarto ë Œë”ë§ ì‹¤íŒ¨ (exit code {e.returncode}):\n"
            stdout_text = self._decode_output(e.stdout) if e.stdout else ""
            stderr_text = self._decode_output(e.stderr) if e.stderr else ""
            
            if stdout_text:
                error_msg += f"--- STDOUT ---\n{stdout_text}\n"
            if stderr_text:
                error_msg += f"--- STDERR ---\n{stderr_text}\n"
            raise RuntimeError(error_msg)
        except FileNotFoundError:
            raise RuntimeError("Quartoê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. https://quarto.org ì—ì„œ ì„¤ì¹˜í•˜ì„¸ìš”.")
    
    def render_to_pdf(self, qmd_path: Path) -> Path:
        """Quarto ë¬¸ì„œë¥¼ PDFë¡œ ë Œë”ë§"""
        
        try:
            result = subprocess.run(
                ['quarto', 'render', str(qmd_path), '--to', 'pdf'],
                capture_output=True,
                check=True,
                timeout=120,
                cwd=str(qmd_path.parent)
            )
            
            pdf_path = qmd_path.with_suffix('.pdf')
            
            if not pdf_path.exists():
                raise FileNotFoundError(f"PDF ìƒì„± ì‹¤íŒ¨: {pdf_path}")
            
            return pdf_path
            
        except subprocess.CalledProcessError as e:
            if e.stderr and (b"pdflatex" in e.stderr or b"xelatex" in e.stderr):
                raise RuntimeError(
                    "PDF ìƒì„±ì— í•„ìš”í•œ LaTeXê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
                    "TinyTeX ì„¤ì¹˜: quarto install tinytex"
                )
            else:
                error_msg = f"PDF ë Œë”ë§ ì‹¤íŒ¨ (exit code {e.returncode}):\n"
                stdout_text = self._decode_output(e.stdout) if e.stdout else ""
                stderr_text = self._decode_output(e.stderr) if e.stderr else ""
                
                if stdout_text:
                    error_msg += f"--- STDOUT ---\n{stdout_text}\n"
                if stderr_text:
                    error_msg += f"--- STDERR ---\n{stderr_text}\n"
                raise RuntimeError(error_msg)
